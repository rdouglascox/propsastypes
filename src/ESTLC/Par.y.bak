-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ESTLC.Par
  ( happyError
  , myLexer
  , pTerm
  , pType
  ) where

import Prelude

import qualified ESTLC.Abs
import ESTLC.Lex

}

%name pTerm Term
%name pType Type
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('     { PT _ (TS _ 1)     }
  ')'     { PT _ (TS _ 2)     }
  '*'     { PT _ (TS _ 3)     }
  '+'     { PT _ (TS _ 4)     }
  ','     { PT _ (TS _ 5)     }
  '->'    { PT _ (TS _ 6)     }
  '.'     { PT _ (TS _ 7)     }
  ':'     { PT _ (TS _ 8)     }
  'A'     { PT _ (TS _ 9)     }
  'B'     { PT _ (TS _ 10)    }
  'Bot'   { PT _ (TS _ 11)    }
  'C'     { PT _ (TS _ 12)    }
  'D'     { PT _ (TS _ 13)    }
  '\\'    { PT _ (TS _ 14)    }
  'abort' { PT _ (TS _ 15)    }
  'as'    { PT _ (TS _ 16)    }
  'case'  { PT _ (TS _ 17)    }
  'fst'   { PT _ (TS _ 18)    }
  'inl'   { PT _ (TS _ 19)    }
  'inr'   { PT _ (TS _ 20)    }
  'of'    { PT _ (TS _ 21)    }
  'snd'   { PT _ (TS _ 22)    }
  '{'     { PT _ (TS _ 23)    }
  '|'     { PT _ (TS _ 24)    }
  '}'     { PT _ (TS _ 25)    }
  L_VarId { PT _ (T_VarId $$) }

%%

VarId :: { ESTLC.Abs.VarId }
VarId  : L_VarId { ESTLC.Abs.VarId $1 }

Term :: { ESTLC.Abs.Term }
Term
  : VarId { ESTLC.Abs.Var $1 }
  | '(' Term Term ')' { ESTLC.Abs.App $2 $3 }
  | '\\' VarId ':' Type '.' Term { ESTLC.Abs.Abs $2 $4 $6 }
  | '{' Term ',' Term '}' { ESTLC.Abs.Pair $2 $4 }
  | 'fst' Term { ESTLC.Abs.Fst $2 }
  | 'snd' Term { ESTLC.Abs.Snd $2 }
  | 'inl' Term 'as' Type { ESTLC.Abs.Inl $2 $4 }
  | 'inr' Term 'as' Type { ESTLC.Abs.Inr $2 $4 }
  | 'case' Term 'of' Term '|' Term { ESTLC.Abs.Case $2 $4 $6 }
  | 'abort' Type Term { ESTLC.Abs.Abort $2 $3 }

Type :: { ESTLC.Abs.Type }
Type
  : 'A' { ESTLC.Abs.A }
  | 'B' { ESTLC.Abs.B }
  | 'C' { ESTLC.Abs.C }
  | 'D' { ESTLC.Abs.D }
  | 'Bot' { ESTLC.Abs.Bot }
  | '(' Type '->' Type ')' { ESTLC.Abs.Func $2 $4 }
  | '(' Type '+' Type ')' { ESTLC.Abs.Sum $2 $4 }
  | '(' Type '*' Type ')' { ESTLC.Abs.Prod $2 $4 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

